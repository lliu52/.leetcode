# 排序

### 归并排序 O(nlogn)

永远都是 O(nlogn)

`MergeSort(left, right);` 代表将范围 [left,right] 的数排序

合并时候，需要一个临时数组，先完成合并再将临时数组的值搬回原数组，注意边界

```java
MergeSort(arr, left, right):
    if left >= right:
        return

    // 1. 找到中间位置
    mid = (left + right) / 2

    // 2. 递归地排序左半部分
    MergeSort(arr, left, mid)

    // 3. 递归地排序右半部分
    MergeSort(arr, mid + 1, right)

    // 4. 合并左右两个有序部分
    Merge(arr, left, mid, right)
```

### 快速排序

O(nlogn) → O($n^2$)

思路，选定基准使得，通过调换数组元素使得，左边的小于，右边的大于，再递归排序左右两侧的范围。递归排序不包含基准元素

```java
Sort(int[] nums, int left, int right){
	if(left<right){
		int p = Partition(int[] nums, int left, int right); // 拿到基准的坐标
		Sort(nums, left, p-1);
		Sort(nums, p+1, right); // 基准不再参与后续的排序
	}
}

Partition(int[] nums, int left, int right){
	int target = nums[right]; // 基准值选择最后一个元素
	int i = left-1; // 小于等于 i 的所有元素都是小于基准的
	int j = left; // 遍历
	// 如果小于等于基准：
	// 交换 i+1 和 j
	// i++ 现在依然是小于等于 i 的所有元素都是小于基准的
	// 如果大于基准，不任何操作 j++
	// 遍历在基准值前停下
	// 完成遍历后的数组为 .... i 小于 | 大于 | 基准
  // 交换 i+1 和 基准
  // 形成 .... 小于 | 基准 | 大于 ....
	// 返回基准最终的坐标
}
```

### 堆排序

使用数组模拟堆排序即可

```java
// 堆化函数保证这个节点作为父节点及以下的所有节点满足
public void Heapify(int[] nums, int total, int parent){
	// 父节点坐标 parent
	// 左右子节点 2*parent+1, 2*parent+2
	// 最大堆保证根节点大于两个子节点，否则调换位置
	// 如果调换发生，则对被调换的子节点递归调用 Heapify
}

// 建堆
// 从最后的非叶子节点向上调用 Heapify
// 最后一个父节点的数组坐标是 n/2-1，其中 n 是数组长度

// 求第 k 大元素，移除栈顶元素可以，将这个元素和最后一个元素交换，维护堆，同时 n--
// 这样被移除的元素还在数组，但是通过 n 排除在堆排序之外
```

### 变种排序题

LCR 164. 破解闯关密码

一个数组里是非负数，有重复，讲数组里所有元素拼接后形成的新数，必须全部使用完成拼接，求最小的新数字

如果只有每个元素都是一位数，[2,6,8,4] 则最小数一定是 2468

本质是递增排序

数组里有些数字可能是多位的，所以递增 a<b 的条件是 a+b<b+a

30, 3 是一个递增因为：303<330

LC 179. 最大数

一样，这次是拼成最大数

---

LCR 170. 逆序对的总数

两个数成一对，位置靠前的数大于位置靠后的数，则是一个逆序对

`[7,5,6,4]` 逆序对有：`(9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)`

给定数组求逆序对个数

数组 [l,r] 的逆序对数量=[l,m] 的逆序对+ [m+1,r] 的逆序对 + 右半部分和左半部分形成的逆序对

归并排序，递增排列，左右两半数组合并成一个数组的时候如果，右侧数组的元素被合并时，该元素比左侧所有未合并的元素都小，且在原数组位置靠后，所以都构成逆序对

归并排序 + 合并时统计逆序对数量

---

LC 315. 计算右侧小于当前元素的个数

上一题的进阶版，求每个元素右侧小于当前值的元素个数

递减排序，每次合并时，如果左侧某个元素被合并，证明该值大于右侧所有未合并的元素，且满足“右侧”

额外需要建立 map 数组

---

LC 561. 数组拆分

长度为偶数的数组拆分成两个一对，在所有拆法中，每一对最小值的和的值最大为多少

递增排序 → 每两个一组 → 最小值为偶数坐标 → 的和

---